
'''
Best Grass

Bessie(소)는 들판에서 풀을 먹기 위해 풀 뭉치의 개수를 세려고 합니다. 들판은 R개의 행과 C개의 열로 이루어진 격자로 표현되며, 격자에는 다음과 같은 기호가 있습니다:

#: 풀 뭉치가 있는 위치
.: 빈 공간
풀 뭉치란 다음 조건을 만족하는 하나 이상의 #로 이루어진 영역을 말합니다:

하나의 #는 독립적인 풀 뭉치가 될 수 있습니다.
두 개 이상의 #가 상하좌우로 연결되어 있으면 하나의 풀 뭉치로 간주합니다.
대각선으로 연결된 #는 같은 풀 뭉치로 간주하지 않습니다.
서로 다른 풀 뭉치는 반드시 떨어져 있어야 합니다.


Bessie(소)는 들판에서 풀을 먹기 위해 풀 뭉치의 개수를 세려고 합니다. 들판은 R개의 행과 C개의 열로 이루어진 격자로 표현되며, 격자에는 다음과 같은 기호가 있습니다:

#: 풀 뭉치가 있는 위치
.: 빈 공간
풀 뭉치란 다음 조건을 만족하는 하나 이상의 #로 이루어진 영역을 말합니다:

하나의 #는 독립적인 풀 뭉치가 될 수 있습니다.
두 개 이상의 #가 상하좌우로 연결되어 있으면 하나의 풀 뭉치로 간주합니다.
대각선으로 연결된 #는 같은 풀 뭉치로 간주하지 않습니다.
서로 다른 풀 뭉치는 반드시 떨어져 있어야 합니다.


입력 형식
첫 번째 줄: 행(R)과 열(C)의 개수를 나타내는 두 정수.
1 ≤ R, C ≤ 100
두 번째 줄부터: R개의 줄에 걸쳐 격자의 상태가 주어집니다.
각 줄은 C개의 문자로 이루어져 있으며, 각 문자는 #(풀 뭉치) 또는 .(빈 칸)입니다.


출력 형식
첫 번째 줄에 풀 뭉치의 총 개수를 나타내는 정수를 출력합니다.

'''

# 행열 입력 받기
R, C = map(int,input().split())
# 개수에 맞게 값을 2차원 리스트로 입력받기
grass = [list(input()) for _ in range(R)]
# 방문 여부는 확인할 수 있게 False로 리스트 초기화
visited = [[False]*C for _ in range(R)]


# 이동할 수 있는 방향 (이 문제에서는 상하좌우 검색)
d = [(0,1),(1,0),(-1,0),(0,-1)]

cnt = 0


def dfs(x,y):
    # 현재 방문한 노드 True로 방문 처리
    visited[x][y]=True
    #리스트를 for문 처리해서 해당 노드의 상하좌우 검색
    for dx,dy in d :
        # 이동좌표 담기
        mx,my = dx+x,dy+y
        ## 예외처리: 빼먹은 부분 ##
        # 좌표가 주어진 범위를 벗어나면 안되니까
        # 주어진 범위내에 있는 인덱스일 때만 절차가 진행되도록
        if 0<=mx <R and 0<=my<C:
            # 만약 현재 노드에 방문을 안했고 값이 "#"라면?
            if not visited[mx][my] and grass[mx][my]=="#":
                dfs(mx,my)
        

for i in range(R):
    for j in range(C):
        if grass[i][j]=="#" and not visited[i][j]:
            dfs(i,j)
            cnt+=1
print(cnt)


